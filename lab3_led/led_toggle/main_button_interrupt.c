/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "gpio.h"

void delay(void)
{
	for(uint32_t i = 0 ; i < 500000 ; i ++);
}

int main(void)
{
	// LED GPIO configuration, refer to gpio.h for possible values
	// Discovery kit with STM32F407VG MCU User manual: hardware and layout, LEDs

	// configure user red LED

	// assign GPIO port base address
	GPIO_RegDef_t *pGPIOLed;
	pGPIOLed = GPIOD; //from button poll

	// assign pin number
	uint8_t GPIO_PinNumber_Led = GPIO_PIN_NO_14;

    // reset
	GPIOD_REG_RESET();

	// enable peripheral clock
	GPIOD_PCLK_EN();

	// configure the LED peripheral register
	//1 . configure the mode of GPIO pin: output
	pGPIOLed->MODER &= ~( 3UL << (2 * GPIO_PinNumber_Led)); //clearing bits, UL represents unsigned long integer with 32 bits
	pGPIOLed->MODER |= (GPIO_MODE_OUT << (2 * GPIO_PinNumber_Led ) ); //setting to desired value

	//2. configure the output type: push-pull
	pGPIOLed->OTYPER &= ~( 1UL << GPIO_PinNumber_Led); //clearing bit
	pGPIOLed->OTYPER |= (GPIO_OP_TYPE_PP << GPIO_PinNumber_Led ); //setting to desired value

	//3. configure the output speed: low speed
	pGPIOLed->OSPEEDR &= ~( 3UL << ( 2 * GPIO_PinNumber_Led)); //clearing bits
	pGPIOLed->OSPEEDR |= (GPIO_SPEED_LOW << ( 2 * GPIO_PinNumber_Led) ); //setting to desired value

	//4. configure the pull-up/pull-down setting: no pull-up/pull-down
	pGPIOLed->PUPDR &= ~( 3UL << ( 2 * GPIO_PinNumber_Led)); //clearing bits
	pGPIOLed->PUPDR |= (GPIO_NO_PUPD << ( 2 * GPIO_PinNumber_Led) ); //setting to desired value


	// Pushbutton GPIO configuration, refer to gpio.h for possible values
	// Discovery kit with STM32F407VG MCU User manual: hardware and layout, Push buttons

	// configure user push button

	// assign GPIO port base address
	GPIO_RegDef_t *pGPIOBtn;
	pGPIOBtn = GPIOA;

	// assign pin number
	uint8_t GPIO_PinNumber_Btn = GPIO_PIN_NO_0;

    // reset
	GPIOA_REG_RESET();

	// enable peripheral clock
	GPIOA_PCLK_EN();

	// configure the push button peripheral register
	//1 . configure the mode of GPIO pin: input
	pGPIOBtn->MODER &= ~( 3UL << (2 * GPIO_PinNumber_Btn)); //clearing bits, UL represents unsigned long integer with 32 bits
	pGPIOBtn->MODER |= (GPIO_MODE_IN << (2 * GPIO_PinNumber_Btn ) ); //setting to desired value

	//2. configure the pull-up/pull-down setting: no pull-up/pull-down
	pGPIOBtn->PUPDR &= ~( 3UL << ( 2 * GPIO_PinNumber_Btn)); //clearing bits
	pGPIOBtn->PUPDR |= (GPIO_NO_PUPD << ( 2 * GPIO_PinNumber_Btn) ); //push-pull


    // this is the NEW part for interrupt
	// configure GPIO pin as the trigger source for external interrupt
	//1. Enable the clock of SYSCFG
	SYSCFG_PCLK_EN();

	//2. Set up the SYSXCFG external interrupt configuration register (SYSCFG_EXTICR) to map the GPIO pin to the
	// external interrupt input line
	// SYSCFG register maps for STM32F42xxx and STM32F43xxx
	// External interrupt/event controller block diagram
	// External interrupt/event GPIO mapping (STM32F405xx/07xx and STM32F415xx/17xx)
	uint8_t temp1 = GPIO_PinNumber_Btn / 4 ; //decide which EXTICR register (0)
	uint8_t temp2 = GPIO_PinNumber_Btn % 4;  //decide which block in EXTICR (0)
	uint8_t portcode = GPIO_BASEADDR_TO_CODE(GPIOA); //configure which port use the EXTI bit line: PA0 use EXTI0
	SYSCFG->EXTICR[temp1] = portcode << ( temp2 * 4);

	//3. Select the active edge that can trigger EXTI, can be a rising edge, a falling edge, or both (EXTI_RTSR/EXTI_FTSR)
	// falling edge triggered
	EXTI->FTSR |= ( 1UL << GPIO_PinNumber_Btn ); // set the corresponding FTSR bit
	EXTI->RTSR &= ~( 1UL << GPIO_PinNumber_Btn); // clear the corresponding RTSR bit

	//4. Enable EXTI by setting bit (unmask) in EXTI interrupt mask register(EXTI_IMR)
	EXTI->IMR |= (1UL << GPIO_PinNumber_Btn);
	//EXTI->IMR &= ~(1 << GPIO_PinNumber_Btn);

	//5. Enable EXTI interrupt on NVIC controller
	//program ISER0 register
	*NVIC_ISER0 |= (1UL << IRQ_NO_EXTI0);//interrupt --> vector table

	/* Loop forever */
	for(;;);
}

// Interrupt Handler
// The function name of the interrupt handler is given by the startup assembly file startup_stm32f407vgtx.s
void EXTI0_IRQHandler(void)
{

    delay(); // wait for debouncing to end

	if ((EXTI->PR & ( 1UL << GPIO_PIN_NO_0)) != 0) // check if interrupt occurred
	{
		// toggle GPIO pin by writing 0/1 to the GPIO port output data register
		GPIOD->ODR  ^= ( 1UL << GPIO_PIN_NO_14);

		//clear the EXTI_PR register corresponding to the pin number by programming it to '1'
		EXTI->PR |= ( 1UL << GPIO_PIN_NO_0);
	}
}
