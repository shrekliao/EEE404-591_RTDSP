/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdint.h>

// for cycle count
// Cortex-M4 technical reference manual: DWT Programmers Model, address
// ARMv7M Architecture Reference Manual: explanation of registers
volatile uint32_t *DWT_CTRL = (uint32_t *) 0xE0001000; // set CYCCNTENA, bit[0] to enable CYCCNT register, clear to disable
volatile uint32_t *DWT_CYCCNT = (uint32_t *) 0xE0001004; // When enabled, CYCCNT increments on each processor clock cycle
volatile uint32_t *DEMCR = (uint32_t *) 0xE000EDFC; //DEMCR: set TRCENA, bit[24] to enable trace, clear to disable

uint32_t it1, it2, cycle_count;      // start and stop flag, cycle count

// for task
#define   SIZE 8	// Defining Array size

int Hsum (int[],int);
void Hmultiply(int[],int[],int[],const int);

int x[SIZE] = {1,1,1,1,1,0,0,0}; // Input array 1
int y[SIZE] = {0,0,0,1,1,1,1,1}; // Input array 2
int p[SIZE]; // Product array
int s; //Summation result


int main(void)
{
	// enable cycle count
	*DEMCR |=  0x01000000;     // enable trace, set bit 24
	*DWT_CYCCNT = 0;           // clear DWT cycle counter
	*DWT_CTRL |=  1;	// enable DWT cycle counter, set bit 0


	it1 = *DWT_CYCCNT;      // store current cycle-count in a variable: start

	// code you want to measure cycle counts for
	Hmultiply(x,y,p, SIZE);
	s = Hsum (p, SIZE);

	it2 = *DWT_CYCCNT;    // store current cycle-count in a variable: end
	cycle_count = it2 - it1; // derive the cycle-count difference: elapsed clock ticks, at SystemCoreClock

	*DWT_CTRL |=  0;         // disable DWT cycle counter, clear bit 0

    /* Loop forever */
	for(;;);
}

// The compiler does not generate prologue and epilogue sequences for functions with __attribute__((naked))
__attribute__ ((naked)) void Hmultiply (int a[], int b[], int c[], const int length)
{
	__asm volatile (
	// a -> r0, b -> r1, c -> r2, length -> r3
			"PUSH {r4, r5, r6, r7, lr}\n\t" // preserve registers used in the function call, save return address

			// loop over the arrays
			"MOV r4, #0\n\t" // loop counter
			"loop0: CMP r4, r3\n\t" // terminate the loop when r4 >= r3
			"BGE exit0\n\t"
			"LDR r5, [r0, r4, LSL #2]\n\t" // load element from array 1: r5 = mem(r0 + r4*4), r4 used as offset, int (32-bit) value, so *4
			"LDR r6, [r1, r4, LSL #2]\n\t" // load element from array 2: r6 = mem(r1 + r4*4)
			"MUL r7, r5, r6\n\t" // multiply
			"STR r7, [r2, r4, LSL #2]\n\t" // store result to array 3: mem(r2 + r4*4) = r7
			"ADD r4, r4, #1\n\t" // increment loop counter
			"B loop0\n\t" // all the labels MUST be unique
			"exit0: POP {r4, r5, r6, r7, pc}\n\t" // restore registers, return from function
    );
}

__attribute__ ((naked)) int Hsum (int a[], const int length)
{
	__asm volatile (
	// a -> r0, length -> r1
			"PUSH {r4, lr}\n\t" // preserve registers used in the function call, save return address

			// loop over the arrays
			"MOV r2, #0\n\t" // loop counter
			"MOV r4, #0\n\t" // clear sum
			"loop1: CMP r2, r1\n\t" // terminate the loop when r2 >= r1
			"BGE exit1\n\t"
			"LDR r3, [r0], #4\n\t" // load array element to r3, post increment r0 by 4
			"ADD r4, r4, r3\n\t" // sum
			"ADD r2, r2, #1\n\t" // increment loop counter
			"B loop1\n\t"
			"exit1: MOV r0, r4\n\t" // save result in r0 to return
			"POP {r4, pc}\n\t" // restore registers, return from function
    );
}




