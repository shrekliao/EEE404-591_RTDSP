/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdint.h>

// for cycle count
// Cortex-M4 technical reference manual: DWT Programmers Model, address
// ARMv7M Architecture Reference Manual: explanation of registers
volatile uint32_t *DWT_CTRL = (uint32_t *) 0xE0001000; // set CYCCNTENA, bit[0] to enable CYCCNT register, clear to disable
volatile uint32_t *DWT_CYCCNT = (uint32_t *) 0xE0001004; // When enabled, CYCCNT increments on each processor clock cycle
volatile uint32_t *DEMCR = (uint32_t *) 0xE000EDFC; //DEMCR: set TRCENA, bit[24] to enable trace, clear to disable

uint32_t it1, it2, cycle_count;      // start and stop flag, cycle count


// for task
#define   SIZE 6	// Defining Array size
int sum (int [],int);
void multiply(int [],int[],int[],const int);

void swap (int *a, int *b);
void circflip(int arr[], const int length);
void circshift(int arr[], const int length);

int x[SIZE] = {1,1,1,1,0,0}; // Input array 1
int y[SIZE] = {1,1,1,0,0,0}; // Input array 2
//int x[SIZE] = {1,1,1,1,1,0,0,0}; // Input array 1
//int y[SIZE] = {0,0,0,1,1,1,1,1}; // Input array 2
int p[SIZE]; // Product array
int s[SIZE]; //Circular convolution result

int main(void)
{

	int i;

	// enable cycle count
	*DEMCR |=  0x01000000;     // enable trace, set bit 24
	*DWT_CYCCNT = 0;                  // clear DWT cycle counter
	*DWT_CTRL |=  1;  // enable DWT cycle counter, set bit 0


	it1 = *DWT_CYCCNT;      // store current cycle-count in a variable: start

	// code you want to measure

	// ===== INSERT YOUR CODE: START =====
	// circular flip input signal x
	circflip(x, SIZE);

	// iterate for size of desired output signal
	for (i=0; i< SIZE; i ++)
	{
	    // multiply each value in input signals
		multiply(x, y, p, SIZE);

		// sum multiplication results and store in circular convolution result array
		s[i] = sum (p, SIZE);

		// circular shift signal x before next iteration
		circshift(x,SIZE);}


	// ===== INSERT YOUR CODE: END =====

	it2 = *DWT_CYCCNT;    // store current cycle-count in a variable: end
	cycle_count = it2 - it1; // derive the cycle-count difference: elapsed clock ticks, at SystemCoreClock

	*DWT_CTRL |=  0;        // disable DWT cycle counter, clear bit 0


    /* Loop forever */
	for(;;);
}

void multiply (int a[] , int b[], int c[], const int length)
{
	int i;

	for (i=0; i< length; i ++)
		c[i] = a [i] * b[i];  // multiply two numbers


}

int sum (int a[], const int length)
{
	int i, sum;
	sum =0;
	for (i = 0;i<length;i++)  // sum element
		sum = sum + a[i];

	return sum;

}


void swap (int *a, int *b)
{
	int c = *a;
	*a = *b;
	*b = c;
}

void circflip(int arr[], const int length)
{
	int j,i;
	j = length-1;
	for (i=1;i<length;i++)
	{
		swap(&arr[i],&arr[j]);

		if (i>=j)
			{break;}
		j = j-1;
	}
}

void circshift(int arr[], const int length)
{
	// circular rotate array by one
	int i, temp;

	temp = arr[length- 1];
	for (i= length - 1;i > 0;i--)
	{
		arr[i]=arr[i-1];
	}
	arr[0] = temp;
}


