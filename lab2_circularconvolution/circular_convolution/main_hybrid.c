/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdint.h>

// for cycle count
// Cortex-M4 technical reference manual: DWT Programmers Model, address
// ARMv7M Architecture Reference Manual: explanation of registers
volatile uint32_t *DWT_CTRL = (uint32_t *) 0xE0001000; // set CYCCNTENA, bit[0] to enable CYCCNT register, clear to disable
volatile uint32_t *DWT_CYCCNT = (uint32_t *) 0xE0001004; // When enabled, CYCCNT increments on each processor clock cycle
volatile uint32_t *DEMCR = (uint32_t *) 0xE000EDFC; //DEMCR: set TRCENA, bit[24] to enable trace, clear to disable

uint32_t it1, it2, cycle_count;      // start and stop flag, cycle count

// for task
#define   SIZE 6	// Defining Array size

int Hsum (int [],int);
void Hmultiply(int [],int[],int[],const int);

void Hcircflip(int[], const int);
void Hcircshift(int[], const int);

int x[SIZE] = {1,1,1,1,0,0}; // Input array 1
int y[SIZE] = {1,1,1,0,0,0}; // Input array 2
//int x[SIZE] = {1,1,1,1,1,0,0,0}; // Input array 1
//int y[SIZE] = {0,0,0,1,1,1,1,1}; // Input array 2
int p[SIZE]; // Product array
int s[SIZE]; //Circular convolution result

int main(void)
{
	int i;

	// enable cycle count
	*DEMCR |=  0x01000000;     // enable trace, set bit 24
	*DWT_CYCCNT = 0;                  // clear DWT cycle counter
	*DWT_CTRL |=  1;  // enable DWT cycle counter, set bit 0


	it1 = *DWT_CYCCNT;      // store current cycle-count in a variable: start

	// code you want to measure

	// ===== INSERT YOUR CODE: START =====
	// circular flip input signal x
	Hcircflip(x,SIZE);
	// iterate for size of desired output signal
	for (i=0; i< SIZE; i ++)
	{
	    // multiply each value in input signals
		Hmultiply(x, y, p, SIZE);

		// sum multiplication results and store in circular convolution result array
		s[i] = Hsum(p, SIZE);

		// circular shift signal x before next iteration
		Hcircshift(x, SIZE);}

	// ===== INSERT YOUR CODE: END =====

	it2 = *DWT_CYCCNT;    // store current cycle-count in a variable: end
	cycle_count = it2 - it1; // derive the cycle-count difference: elapsed clock ticks, at SystemCoreClock

	*DWT_CTRL |=  0;        // disable DWT cycle counter, clear bit 0

    /* Loop forever */
	for(;;);
}


// The compiler does not generate prologue and epilogue sequences for functions with __attribute__((naked))
__attribute__ ((naked)) void Hmultiply (int a[], int b[], int c[], const int length)
{
	__asm volatile (
	// a -> r0, b -> r1, c -> r2, length -> r3
			"PUSH {r4, r5, r6, r7, lr}\n\t" // preserve registers used in the function call, save return address

			// loop over the arrays
			"MOV r4, #0\n\t" // loop counter
			"loop0: CMP r4, r3\n\t" // terminate the loop when r4 >= r3
			"BGE exit0\n\t"
			"LDR r5, [r0, r4, LSL #2]\n\t" // load element from array 1: r5 = mem(r0 + r4*4), r4 used as offset, int (32-bit) value, so *4
			"LDR r6, [r1, r4, LSL #2]\n\t" // load element from array 2: r6 = mem(r1 + r4*4)
			"MUL r7, r5, r6\n\t" // multiply
			"STR r7, [r2, r4, LSL #2]\n\t" // store result to array 3: mem(r2 + r4*4) = r7
			"ADD r4, r4, #1\n\t" // increment loop counter
			"B loop0\n\t" // all the labels MUST be unique
			"exit0: POP {r4, r5, r6, r7, pc}\n\t" // restore registers, return from function
    );
}

__attribute__ ((naked)) int Hsum (int a[], const int length)
{
	__asm volatile (
	// a -> r0, length -> r1
			"PUSH {r4, lr}\n\t" // preserve registers used in the function call, save return address

			// loop over the arrays
			"MOV r2, #0\n\t" // loop counter
			"MOV r4, #0\n\t" // clear sum
			"loop1: CMP r2, r1\n\t" // terminate the loop when r2 >= r1
			"BGE exit1\n\t"
			"LDR r3, [r0], #4\n\t" // load array element to r3, post increment r0 by 4
			"ADD r4, r4, r3\n\t" // sum
			"ADD r2, r2, #1\n\t" // increment loop counter
			"B loop1\n\t"
			"exit1: MOV r0, r4\n\t" // save result in r0 to return
			"POP {r4, pc}\n\t" // restore registers, return from function
    );
}

__attribute__ ((naked)) void Hcircflip(int arr[], const int length)
{
	__asm volatile (
	// arr -> r0, length -> r1
			"PUSH {r4, r5, lr}\n\t" // preserve registers used in the function call, save return address
			// loop over the array
			"MOV r2, #1\n\t" //loop index (flip index 1: i)
			"SUB r3, r1, #1\n\t" //flip index 2: j
			"loop2: CMP r2, r1\n\t"  // if i >= length, terminate the loop
			"BGE exit2\n\t"

			// swap
			"LDR r4, [r0, r2, LSL #2]\n\t"
			"LDR r5, [r0, r3, LSL #2]\n\t"
			"STR r5, [r0, r2, LSL #2]\n\t"
			"STR r4, [r0, r3, LSL #2]\n\t"

			// break if i >= j
			"CMP r2, r3\n\t"
			"BGE exit2\n\t"

            // update swap indices
			"ADD r2, r2, #1\n\t"
			"SUB r3, r3, #1\n\t"

			"B loop2\n\t"
			"exit2: POP {r4, r5, pc}\n\t" // restore registers, return from function
    );

}

__attribute__ ((naked)) void Hcircshift(int arr[], const int length)
{
	// circular rotate array by one
	__asm volatile (
	// arr -> r0, length -> r1
			"PUSH {r4, r5, lr}\n\t" // preserve registers used in the function call, save return address
			// loop over the array
			"SUB r2, r1, #1\n\t" //loop index: start from last element
			"LDR r3, [r0, r2, LSL #2]\n\t" //save the last element

			"loop3: CMP r2, #0\n\t" // if i <= 0, terminate the loop
			"BLE exit3\n\t"

			// circular shift right by 1
			"SUB r4, r2, #1\n\t"
			"LDR r5, [r0, r4, LSL #2]\n\t"
			"STR r5, [r0, r2, LSL #2]\n\t"

            // update loop index
			"MOV r2, r4\n\t"

			"B loop3\n\t"
			"exit3: STR r3, [r0]\n\t" // store the last element to be the first element
			"POP {r4, r5, pc}\n\t" // restore registers, return from function
	);

}

